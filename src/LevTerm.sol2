// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.18;

import {BaseStrategy, ERC20} from "@tokenized-strategy/BaseStrategy.sol";

import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";

import {ILevTermEscrow} from "src/interfaces/ILevTermEscrow.sol";

import {ITermAuction} from "src/interfaces/term/ITermAuction.sol";
import {ITermRepoServicer} from "src/interfaces/term/ITermRepoServicer.sol";
import {ExponentialNoError} from "src/lib/ExponentialNoError.sol";
import {ITermAuctionBidLocker} from "src/interfaces/term/ITermAuctionBidLocker.sol";
import {ITermRepoCollateralManager} from "src/interfaces/term/ITermRepoCollateralManager.sol";

// AAVE interfaces
import {IPool, IPoolAddressesProvider, DataTypes} from "@aave-v3/contracts/interfaces/IPool.sol";
import {FlashLoanSimpleReceiverBase} from "@aave-v3/contracts/flashloan/base/FlashLoanSimpleReceiverBase.sol";
import {IStaticATokenLM} from "src/interfaces/bgd/IStaticATokenLM.sol";

/// @title LevTerm
/// @notice A Yearn V3 strategy that bids on Term Finance auctions
/// @notice Bridge loan facility provided via LevTermEscrow
contract LevTerm is BaseStrategy, ExponentialNoError, FlashLoanSimpleReceiverBase {
    using SafeERC20 for ERC20;

    ILevTermEscrow public immutable termEscrow;
    ITermRepoServicer public termRepoServicer;

    // Locks
    bool withdrawLock;
    bool depositLock;

    // Escrow fee
    uint256 escrowFeeBps;

    AuctionInfo public auction;

    struct AuctionInfo {
        ITermAuction termAuction;
        ITermAuctionBidLocker bidLocker;
        ITermRepoServicer repoServicer;
        ITermRepoCollateralManager collateralManager;
        uint256 collateralAmount;
        address purchaseToken;
        uint256 purchaseTokenAmount;
        uint256 escrowDebt;
        uint256 servicingFeeProRatedMantissa;
    }

    IPool public constant lendingPool = IPool(0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2);

    address public constant staticATokenFactory = 0x90b1255a76e847cC92d41C295DeD5Bf2D4F24B3d;
    IStaticATokenLM public statAToken;
    address nativeToken;

    /// @param _asset Native asset for the tokenized strategy
    /// @param _name Name of the strategy
    /// @param _termEscrow Address of the TermEscrow contract that provides bridge loans
    constructor(address _asset, string memory _name, address _termEscrow, uint256 _escrowFeeBps)
        BaseStrategy(_asset, _name)
        FlashLoanSimpleReceiverBase(IPoolAddressesProvider(address(lendingPool)))
    {
        termEscrow = ILevTermEscrow(_termEscrow);
        require(_escrowFeeBps <= 15, "Fee cap of 15bps exceeded");
        escrowFeeBps = _escrowFeeBps;

        statAToken = IStaticATokenLM(_asset);

        nativeToken = statAToken.aTokenUnderlying();
        ERC20(nativeToken).safeApprove(address(statAToken), type(uint256).max);
    }

    // ========================================================================
    // = Base strategy override ===============================================
    // ========================================================================

    function _deployFunds(uint256 _amount) internal override {}

    function _freeFunds(uint256 _amount) internal override {}

    function _harvestAndReport() internal override returns (uint256 _totalAssets) {
        _totalAssets = asset.balanceOf(address(this));
    }

    function availableDepositLimit(address _owner) public view override returns (uint256) {
        if (depositLock) {
            return 0;
        }
        return type(uint256).max;
    }

    function availableWithdrawLimit(address _owner) public view override returns (uint256) {
        if (withdrawLock) {
            return 0;
        }
        return type(uint256).max;
    }

    // ========================================================================
    // = HELPERS ==============================================================
    // ========================================================================

    /// @notice Allows to lock deposits and withdrawals via `availableDepositLimit` and `availableWithdrawLimit`
    function _lock(bool _deposits, bool _withdrawals) internal {
        depositLock = _deposits;
        withdrawLock = _withdrawals;
    }

    /// @notice Repayment of debt to escrow contract, and reset accounting
    function _repayEscrow() internal {
        asset.transfer(address(termEscrow), auction.escrowDebt * (10_000 + escrowFeeBps) / 10_000);
        auction.escrowDebt = 0;
    }

    // ========================================================================
    // = TERM SPECIFIC ========================================================
    // ========================================================================

    /// @notice Allows management to place a bid in a Term auction
    /// @param _termAuction Address of the auction
    /// @param _idHash Obfuscated id hash
    /// @param _bidPriceHash Obfuscated bid price hash (interest rate, in 1e18)
    /// @param _purchaseTokenAmount Amount of assets to borrow
    /// @param _collateralAmount Amount of assets to supply
    function bidOnNewAuction(
        address _termAuction,
        bytes32 _idHash,
        bytes32 _bidPriceHash,
        uint256 _purchaseTokenAmount,
        uint256 _collateralAmount
    ) external onlyManagement returns (bytes32[] memory bidIds) {
        auction.termAuction = ITermAuction(_termAuction);
        auction.bidLocker = ITermAuctionBidLocker(auction.termAuction.termAuctionBidLocker());
        require(auction.bidLocker.collateralTokens(address(asset)), "Wrong collateral");
        require(
            block.timestamp > auction.bidLocker.auctionStartTime()
                || block.timestamp < auction.termAuction.auctionEndTime(),
            "Auction not open"
        );

        auction.repoServicer = ITermRepoServicer(auction.bidLocker.termRepoServicer());
        auction.collateralManager = ITermRepoCollateralManager(auction.bidLocker.termRepoCollateralManager());

        // Calculate amount required from escrow
        uint256 toPullFromEscrow = _collateralAmount - asset.balanceOf(address(this));

        auction.servicingFeeProRatedMantissa = mul_(
            Exp({mantissa: auction.bidLocker.dayCountFractionMantissa()}),
            Exp({mantissa: auction.repoServicer.servicingFee()})
        ).mantissa;

        require(asset.balanceOf(address(termEscrow)) >= toPullFromEscrow, "Escrow does not hold sufficient funds");
        require(
            _collateralTokenToPurchaseToken(toPullFromEscrow)
                <= auction.purchaseTokenAmount * 1e18 / (1e18 - auction.servicingFeeProRatedMantissa),
            "Resulting balance insufficient to repay Escrow"
        );

        // Pull funds from escrow
        termEscrow.pullFromEscrow(toPullFromEscrow);

        // Store params for accounting
        auction.collateralAmount = asset.balanceOf(address(this));
        auction.purchaseToken = auction.bidLocker.purchaseToken();
        auction.purchaseTokenAmount = _purchaseTokenAmount;
        auction.escrowDebt = toPullFromEscrow;

        uint256[] memory collateralAmounts = new uint256[](1);
        collateralAmounts[0] = auction.collateralAmount;

        address[] memory collateralTokens = new address[](1);
        collateralTokens[0] = address(asset);

        // Approve Repo Locker to pull collateral amount
        ERC20(asset).approve(address(auction.repoServicer.termRepoLocker()), collateralAmounts[0]);

        // Create bid submission struct and submit bid
        ITermAuctionBidLocker.TermAuctionBidSubmission memory bid = ITermAuctionBidLocker.TermAuctionBidSubmission({
            id: _idHash,
            bidder: address(this),
            bidPriceHash: _bidPriceHash,
            amount: _purchaseTokenAmount,
            collateralAmounts: collateralAmounts,
            purchaseToken: auction.purchaseToken,
            collateralTokens: collateralTokens
        });

        ITermAuctionBidLocker.TermAuctionBidSubmission[] memory bids =
            new ITermAuctionBidLocker.TermAuctionBidSubmission[](1);
        bids[0] = bid;
        bidIds = auction.bidLocker.lockBids(bids);

        // Lock deposits and withdrawals
        _lock(true, true);
    }

    /// @notice Permissionless function callable the auction ended
    /// @notice 3 scenarios possible: full fill, partial fill, no fill
    function auctionClosed() public {
        require(block.timestamp > auction.termAuction.auctionEndTime(), "Auction still open");
        uint256 assetBalance = asset.balanceOf(address(this));

        // No fill: Collateral borrowed from escrow returned, unlock deposits and withdrawals
        if (assetBalance == auction.collateralAmount) {
            _repayEscrow();
            _lock(false, false);
            return;
        }

        uint256 purchaseTokenBalance = ERC20(auction.purchaseToken).balanceOf(address(this));

        // Partial fill: Unlock collateral pro-rated to the purchase token received
        if (purchaseTokenBalance != auction.purchaseTokenAmount * 1e18 / (1e18 - auction.servicingFeeProRatedMantissa))
        {
            auction.collateralManager.externalUnlockCollateral(
                address(asset), auction.collateralAmount * purchaseTokenBalance / auction.purchaseTokenAmount
            );
        }

        // Swap all purchase token to asset and repay escrow
        _swapPurchaseTokenToAsset();
        _repayEscrow();
    }

    /// @notice Permissionless function callable after loan maturity
    /// @notice Repays loan, settles debt with escrow (if any), calls report and unlocks withdrawals
    function closeLoan() public {
        require(block.timestamp >= auction.repoServicer.maturityTimestamp(), "Before maturity");
        require(block.timestamp < auction.repoServicer.endOfRepurchaseWindow(), "Repurchase window closed");

        // Obtain the required amount of purchase token for full repayment
        _repayTermLoan(auction.repoServicer.getBorrowerRepurchaseObligation(address(this)));

        // If there is some debt to escrow remaining, repay
        if (auction.escrowDebt > 0) {
            _repayEscrow();
        }

        // Call report, realizing profit
        _delegateCall(abi.encode(TokenizedStrategy.report.selector));

        // Remove withdrawal lock
        _lock(true, false);
    }

    /// @notice Allows management to top off collateral, with option to pull from escrow contract
    /// @param _collateralToAdd Amount of collateral to add
    /// @param _pullFromEscrow Bool to determine if we pull funds from escrow
    function lockCollateral(uint256 _collateralToAdd, bool _pullFromEscrow) external onlyManagement {
        if (_pullFromEscrow) {
            termEscrow.pullFromEscrow(_collateralToAdd);
            auction.escrowDebt += _collateralToAdd;
        }
        auction.collateralManager.externalLockCollateral(address(asset), _collateralToAdd);
    }

    /// @notice Emergency function callable by management to repay escrow contract
    function emergencyRepayEscrow() external onlyManagement {
        uint256 availableAsset = asset.balanceOf(address(this));
        uint256 toRepay = Math.min(availableAsset, auction.escrowDebt);
        asset.transfer(address(termEscrow), toRepay);
        auction.escrowDebt = auction.escrowDebt - toRepay;
    }

    /// @notice Allow management to change escrow fee
    /// @param _escrowFeeBps New escrow fee, in bps
    function setEscrowFeeBps(uint256 _escrowFeeBps) external onlyManagement {
        require(_escrowFeeBps <= 15, "Fee cap of 15bps exceeded");
        escrowFeeBps = _escrowFeeBps;
    }

    // ========================================================================
    // = ASSET PAIR SPECIFIC ==================================================
    // ========================================================================

    /// @notice Conversion from collateral token to purchase token
    function _collateralTokenToPurchaseToken(uint256 _collateralTokenAmount) internal returns (uint256) {
        return statAToken.convertToAssets(_collateralTokenAmount);
    }

    /// @notice Purchase token (native token) --> Asset (statAToken)
    function _swapPurchaseTokenToAsset() internal {
        statAToken.deposit(ERC20(nativeToken).balanceOf(address(this)), address(this), 0, false);
    }

    /// @notice Get purchase token via AAVE V3 flashloan
    function _repayTermLoan(uint256 _purchaseTokenAmount) internal {
        POOL.flashLoanSimple(address(this), nativeToken, _purchaseTokenAmount, "", 0);
    }

    /// @notice AAVE V3 flashloan logic
    function executeOperation(address asset, uint256 amount, uint256 premium, address initiator, bytes calldata params)
        external
        override
        returns (bool)
    {
        require(initiator == address(this), "FlashBorrower: Untrusted loan initiator");

        // Approve RepoLocker, repay Term loan, free up collateral
        ERC20(auction.purchaseToken).approve(address(auction.repoServicer.termRepoLocker()), amount);
        auction.repoServicer.submitRepurchasePayment(amount);

        // Swap some statAToken to repay flashloan + fee
        uint256 totalAmount = amount + premium;

        statAToken.withdraw(statAToken.convertToShares(totalAmount), address(this), address(this));

        // Repay flashloan
        ERC20(asset).approve(address(POOL), totalAmount);

        return true;
    }
}
